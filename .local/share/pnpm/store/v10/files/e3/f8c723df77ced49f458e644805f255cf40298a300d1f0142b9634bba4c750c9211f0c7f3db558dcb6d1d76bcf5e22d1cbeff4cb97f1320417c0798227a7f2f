"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  GambaContext: () => GambaContext,
  GambaProvider: () => GambaProvider,
  SendTransactionContext: () => SendTransactionContext,
  SendTransactionProvider: () => SendTransactionProvider,
  createCustomFeePlugin: () => createCustomFeePlugin,
  throwTransactionError: () => throwTransactionError,
  useAccount: () => useAccount,
  useBalance: () => useBalance,
  useGamba: () => useGamba,
  useGambaContext: () => useGambaContext,
  useGambaEventListener: () => useGambaEventListener,
  useGambaEvents: () => useGambaEvents,
  useGambaPlay: () => useGambaPlay,
  useGambaProgram: () => useGambaProgram,
  useGambaProvider: () => useGambaProvider,
  useNextResult: () => useNextResult,
  usePool: () => usePool,
  useSendTransaction: () => useSendTransaction,
  useTransactionError: () => useTransactionError,
  useTransactionStore: () => useTransactionStore,
  useWalletAddress: () => useWalletAddress
});
module.exports = __toCommonJS(src_exports);

// src/SendTransactionContext.tsx
var import_react = __toESM(require("react"));
var defaultValue = {
  priorityFee: 100001,
  simulationUnits: 14e5,
  computeUnitLimitMargin: 1.1
};
var SendTransactionContext = import_react.default.createContext(defaultValue);
function SendTransactionProvider({ children, ...props }) {
  return /* @__PURE__ */ import_react.default.createElement(SendTransactionContext.Provider, { value: { ...defaultValue, ...props } }, children);
}

// src/GambaProvider.tsx
var import_wallet_adapter_react = require("@solana/wallet-adapter-react");
var import_gamba_core_v2 = require("gamba-core-v2");
var import_react2 = __toESM(require("react"));
var GambaContext = import_react2.default.createContext({
  provider: null,
  plugins: [],
  addPlugin: () => null
});
function useGambaContext() {
  const context = import_react2.default.useContext(GambaContext);
  if (!context)
    throw new Error("No GambaContext");
  return context;
}
function GambaProvider({ plugins: _plugins = [], children }) {
  const [plugins, setPlugins] = (0, import_react2.useState)(_plugins);
  const { connection } = (0, import_wallet_adapter_react.useConnection)();
  const walletContext = (0, import_wallet_adapter_react.useWallet)();
  const wallet = (0, import_react2.useMemo)(
    () => {
      if (walletContext.connected && walletContext.wallet?.adapter?.publicKey) {
        return walletContext.wallet.adapter;
      }
    },
    [walletContext]
  );
  const provider = (0, import_react2.useMemo)(
    () => {
      return new import_gamba_core_v2.GambaProvider(
        connection,
        wallet
      );
    },
    [connection, wallet]
  );
  const addPlugin = (plugin) => {
    setPlugins((plugins2) => [...plugins2, plugin]);
    return () => {
      setPlugins(
        (plugins2) => plugins2.filter((p) => p !== plugin)
      );
    };
  };
  return /* @__PURE__ */ import_react2.default.createElement(GambaContext.Provider, { value: {
    provider,
    plugins,
    addPlugin
  } }, children);
}

// src/hooks/useAccount.ts
var import_signals_react = require("@preact/signals-react");
var import_wallet_adapter_react2 = require("@solana/wallet-adapter-react");
var import_web3 = require("@solana/web3.js");
var import_react3 = __toESM(require("react"));
var DEFAULT_DEBOUNCE_MS = 1;
var nextBatch = (0, import_signals_react.signal)(/* @__PURE__ */ new Set());
var data = (0, import_signals_react.signal)({});
var fetchTimeout;
function useAccount(address, decoder) {
  const { connection } = (0, import_wallet_adapter_react2.useConnection)();
  const fetchedData = data.value[address.toString()];
  import_react3.default.useEffect(() => {
    nextBatch.value.add(address.toString());
    clearTimeout(fetchTimeout);
    fetchTimeout = setTimeout(async () => {
      const unique = Array.from(nextBatch.value).filter((x) => !Object.keys(data.value).includes(x));
      if (!unique.length) {
        return;
      }
      const accounts = await connection.getMultipleAccountsInfo(unique.map((x) => new import_web3.PublicKey(x)));
      console.debug("Fetching accounts", unique);
      const newData = unique.reduce((prev, curr, ci) => {
        return { ...prev, [curr]: accounts[ci] };
      }, {});
      data.value = { ...data.value, ...newData };
      nextBatch.value.clear();
    }, DEFAULT_DEBOUNCE_MS);
    const subscription = connection.onAccountChange(address, (info) => {
      data.value = { ...data.value, [address.toString()]: info };
    });
    return () => {
      clearTimeout(fetchTimeout);
      connection.removeAccountChangeListener(subscription);
    };
  }, [address.toString()]);
  try {
    return decoder(fetchedData);
  } catch (error) {
    console.log(error);
    return;
  }
}

// src/hooks/useBalances.ts
var import_wallet_adapter_react3 = require("@solana/wallet-adapter-react");
var import_web32 = require("@solana/web3.js");
var import_gamba_core_v22 = require("gamba-core-v2");
var emptyAccount = new import_web32.Keypair();
function useWalletAddress() {
  const wallet = (0, import_wallet_adapter_react3.useWallet)();
  return wallet.publicKey ?? emptyAccount.publicKey;
}
function useBalance(publicKey, token, authority) {
  const ata = (0, import_gamba_core_v22.getUserUnderlyingAta)(publicKey, token);
  const bonusAta = (0, import_gamba_core_v22.getUserBonusAtaForPool)(publicKey, (0, import_gamba_core_v22.getPoolAddress)(token, authority));
  const userAccount = useAccount(publicKey, (info) => info);
  const tokenAccount = useAccount(ata, import_gamba_core_v22.decodeAta);
  const bonusAccount = useAccount(bonusAta, import_gamba_core_v22.decodeAta);
  const nativeBalance = Number(userAccount?.lamports ?? 0);
  const balance = Number(tokenAccount?.amount ?? 0);
  const bonusBalance = Number(bonusAccount?.amount ?? 0);
  return {
    nativeBalance,
    balance: (0, import_gamba_core_v22.isNativeMint)(token) ? nativeBalance : balance,
    bonusBalance
  };
}

// src/hooks/useGamba.ts
var import_wallet_adapter_react6 = require("@solana/wallet-adapter-react");
var import_gamba_core_v24 = require("gamba-core-v2");

// src/hooks/useGambaPlay.ts
var import_wallet_adapter_react5 = require("@solana/wallet-adapter-react");
var import_web34 = require("@solana/web3.js");
var import_gamba_core_v23 = require("gamba-core-v2");
var import_react5 = __toESM(require("react"));

// src/hooks/useSendTransaction.ts
var import_anchor = require("@coral-xyz/anchor");
var import_wallet_adapter_react4 = require("@solana/wallet-adapter-react");
var import_web33 = require("@solana/web3.js");
var import_react4 = __toESM(require("react"));

// src/PubSub.ts
var PubSub = class {
  listeners = [];
  emit(...payload) {
    for (const listener of this.listeners) {
      listener(...payload);
    }
  }
  unsubscribe(listener) {
    const index = this.listeners.indexOf(listener);
    if (index < 0) {
      console.warn("Event listener not found");
      return;
    }
    this.listeners.splice(index, 1);
  }
  subscribe(listener) {
    this.listeners.push(listener);
    return () => this.unsubscribe(listener);
  }
};

// src/hooks/useTransactionStore.ts
var import_zustand = require("zustand");
var useTransactionStore = (0, import_zustand.create)(
  (set) => ({
    txId: void 0,
    label: void 0,
    state: "none",
    set
  })
);

// src/hooks/useSendTransaction.ts
var transactionEventEmitter = new PubSub();
var throwTransactionError = (error) => {
  transactionEventEmitter.emit(error);
  return error;
};
function useTransactionError(callback) {
  import_react4.default.useLayoutEffect(
    () => transactionEventEmitter.subscribe(callback),
    [callback]
  );
}
var getErrorLogs = (error) => {
  if (typeof error === "object" && !!error && "logs" in error && Array.isArray(error.logs))
    return error.logs;
  return null;
};
function useSendTransaction() {
  const store = useTransactionStore();
  const { connection } = (0, import_wallet_adapter_react4.useConnection)();
  const wallet = (0, import_wallet_adapter_react4.useWallet)();
  const context = import_react4.default.useContext(SendTransactionContext);
  return async (instructions, opts) => {
    try {
      store.set({ state: "simulating", label: opts?.label });
      if (!wallet.publicKey || !wallet.signTransaction) {
        throw new Error("Wallet Not Connected");
      }
      const payer = wallet.publicKey;
      if (!Array.isArray(instructions)) {
        instructions = [
          instructions
        ];
      }
      const priorityFee = opts?.priorityFee ?? context.priorityFee;
      const resolvedInstructions = await Promise.all(instructions);
      const lookupTableAddresses = opts?.lookupTable ?? [];
      const lookupTables = await Promise.all(
        lookupTableAddresses.map(async (x) => {
          const response = await connection.getAddressLookupTable(x);
          return response?.value;
        }).filter((x) => !!x)
      );
      const createTx = async (units, recentBlockhash = import_web33.PublicKey.default.toString()) => {
        const message = new import_web33.TransactionMessage({
          payerKey: payer,
          recentBlockhash,
          instructions: [
            ...priorityFee ? [import_web33.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: priorityFee })] : [],
            import_web33.ComputeBudgetProgram.setComputeUnitLimit({ units }),
            ...resolvedInstructions
          ]
        }).compileToV0Message(lookupTables);
        return new import_web33.VersionedTransaction(message);
      };
      const computeUnitLimit = await (async () => {
        if (opts?.computeUnits) {
          return opts.computeUnits;
        }
        const simulatedTx = await createTx(context.simulationUnits);
        const simulation = await connection.simulateTransaction(simulatedTx, { replaceRecentBlockhash: true, sigVerify: false });
        if (simulation.value.err) {
          throw simulation.value.err;
        }
        if (!simulation.value.unitsConsumed) {
          throw new Error("Simulation did not consume any units.");
        }
        return Math.floor(simulation.value.unitsConsumed * (opts?.computeUnitLimitMargin ?? 1));
      })();
      const transaction = await createTx(computeUnitLimit, (await connection.getLatestBlockhash(context.blockhashCommitment)).blockhash);
      const serialized = transaction.serialize();
      const size = serialized.length + 1 + transaction.signatures.length * 64;
      console.log("SIZE", size);
      const signedTransaction = await wallet.signTransaction(transaction);
      store.set({ state: "sending" });
      const txId = await connection.sendTransaction(signedTransaction, {
        skipPreflight: true,
        preflightCommitment: context.blockhashCommitment
      });
      store.set({ state: "processing", txId });
      console.debug("TX sent", txId);
      const blockhash = await connection.getLatestBlockhash(context.blockhashCommitment);
      const confirmStrategy = {
        blockhash: blockhash.blockhash,
        lastValidBlockHeight: blockhash.lastValidBlockHeight,
        signature: txId
      };
      connection.confirmTransaction(confirmStrategy, "processed").then((x) => {
        console.debug("TX processed", x);
        store.set({
          state: "confirming",
          txId,
          signatureResult: x.value
        });
      });
      connection.confirmTransaction(confirmStrategy, "confirmed").then((x) => {
        console.debug("TX confirmed", x);
        store.set({ state: "none" });
      });
      if (opts?.confirmation) {
        await connection.confirmTransaction(confirmStrategy, opts.confirmation);
      }
      return txId;
    } catch (err) {
      const logs = getErrorLogs(err);
      const error = (() => {
        if (logs) {
          const anchorError = import_anchor.AnchorError.parse(logs);
          if (anchorError) {
            return anchorError;
          }
        }
        return err;
      })();
      if (logs) {
        console.error("Error Logs:\n", logs.join("\n"));
      }
      store.set({ state: "error" });
      throw throwTransactionError(error);
    }
  };
}

// src/hooks/useGambaPlay.ts
function useGambaPlay() {
  const { connected } = (0, import_wallet_adapter_react5.useWallet)();
  const sendTx = useSendTransaction();
  const context = import_react5.default.useContext(GambaContext);
  const provider = useGambaProvider();
  return async function play(input, additionalInstructions = [], opts) {
    const creator = new import_web34.PublicKey(input.creator);
    const creatorFee = input.creatorFee ?? 0;
    const jackpotFee = input.jackpotFee ?? 0;
    const meta = input.metadata?.join(":") ?? "";
    const token = new import_web34.PublicKey(input.token ?? import_gamba_core_v23.NATIVE_MINT);
    const poolAuthority = new import_web34.PublicKey(input.poolAuthority ?? import_gamba_core_v23.SYSTEM_PROGRAM);
    if (!connected) {
      throw throwTransactionError(new Error("NOT_CONNECTED"));
    }
    const pluginInput = {
      wallet: provider.user,
      creator,
      token,
      wager: input.wager,
      bet: input.bet,
      input
    };
    const pluginContext = {
      creatorFee,
      provider
    };
    const pluginInstructions = [];
    for (const plugin of context.plugins) {
      const resolved = await plugin(pluginInput, pluginContext);
      if (resolved) {
        pluginInstructions.push(...resolved);
      }
    }
    const pool = (0, import_gamba_core_v23.getPoolAddress)(token, poolAuthority);
    return sendTx(
      [
        ...additionalInstructions,
        provider.play(
          input.wager,
          input.bet,
          input.clientSeed ?? "",
          pool,
          token,
          creator,
          pluginContext.creatorFee,
          jackpotFee,
          meta,
          input.useBonus ?? false
        ),
        ...pluginInstructions
      ],
      { ...opts, label: "play", lookupTable: opts?.lookupTables }
    );
  };
}

// src/hooks/useGamba.ts
function useNextResult() {
  const { connection } = (0, import_wallet_adapter_react6.useConnection)();
  const userAddress = useWalletAddress();
  const game = useAccount((0, import_gamba_core_v24.getGameAddress)(userAddress), import_gamba_core_v24.decodeGame);
  return () => {
    const prevNonce = game?.nonce?.toNumber() ?? 0;
    return (0, import_gamba_core_v24.getNextResult)(connection, userAddress, prevNonce);
  };
}
function useGamba() {
  const userAddress = useWalletAddress();
  const game = useAccount((0, import_gamba_core_v24.getGameAddress)(userAddress), import_gamba_core_v24.decodeGame);
  const userCreated = !!game;
  const nextRngSeedHashed = game?.nextRngSeedHashed;
  const txStore = useTransactionStore();
  const isPlaying = txStore.state !== "error" && txStore.state !== "none" || !!game?.status.resultRequested;
  const play = useGambaPlay();
  const result = useNextResult();
  return {
    play,
    result,
    userCreated,
    nonce: Number(game?.nonce?.toNumber()),
    nextRngSeedHashed,
    game,
    isPlaying
  };
}

// src/hooks/useGambaEvents.ts
var import_wallet_adapter_react7 = require("@solana/wallet-adapter-react");
var import_gamba_core_v25 = require("gamba-core-v2");
var import_react6 = __toESM(require("react"));
function useGambaEventListener(eventName, callback, deps = []) {
  const program = useGambaProgram();
  import_react6.default.useEffect(() => {
    const listener = program.addEventListener(
      eventName,
      (data2, slot, signature) => {
        const event = {
          signature,
          time: Date.now(),
          name: eventName,
          data: data2
        };
        callback(event);
      }
    );
    return () => {
      program.removeEventListener(listener);
    };
  }, [eventName, program, ...deps]);
}
function useGambaEvents(eventName, props = {}) {
  const { signatureLimit = 30 } = props;
  const { connection } = (0, import_wallet_adapter_react7.useConnection)();
  const [events, setEvents] = import_react6.default.useState([]);
  const address = props.address ?? import_gamba_core_v25.PROGRAM_ID;
  import_react6.default.useEffect(
    () => {
      (0, import_gamba_core_v25.fetchGambaTransactions)(
        connection,
        address,
        { limit: signatureLimit }
      ).then((x) => setEvents(x));
    },
    [connection, signatureLimit, address]
  );
  return import_react6.default.useMemo(
    () => events.filter((x) => x.name === eventName),
    [eventName, events]
  );
}

// src/hooks/usePool.ts
var import_gamba_core_v26 = require("gamba-core-v2");
function usePool(token, authority = import_gamba_core_v26.SYSTEM_PROGRAM) {
  const publicKey = (0, import_gamba_core_v26.getPoolAddress)(token, authority);
  const account = useAccount(publicKey, import_gamba_core_v26.decodePool);
  const gambaState = useAccount((0, import_gamba_core_v26.getGambaStateAddress)(), import_gamba_core_v26.decodeGambaState);
  const jackpotUnderlyingTokenAccount = useAccount((0, import_gamba_core_v26.getPoolJackpotTokenAccountAddress)(publicKey), import_gamba_core_v26.decodeAta);
  const jackpotBalance = jackpotUnderlyingTokenAccount?.amount ?? BigInt(0);
  if (!account) {
    return {
      token,
      publicKey,
      liquidity: BigInt(0),
      minWager: 0,
      maxPayout: 0,
      gambaFee: 0,
      poolFee: 0,
      jackpotBalance: 0,
      authority
    };
  }
  const liquidity = BigInt(account.liquidityCheckpoint);
  const customGambaFeeBps = account.customGambaFeeBps.toNumber();
  const customPoolFeeBps = account.customPoolFeeBps.toNumber();
  const gambaFee = ((customGambaFeeBps || gambaState?.gambaFeeBps.toNumber()) ?? 0) / import_gamba_core_v26.BPS_PER_WHOLE;
  const poolFee = ((customPoolFeeBps || gambaState?.defaultPoolFee.toNumber()) ?? 0) / import_gamba_core_v26.BPS_PER_WHOLE;
  const maxPayoutBps = (account.customMaxPayoutBps?.toNumber() || gambaState?.maxPayoutBps?.toNumber()) ?? 0;
  const maxPayout = Number(liquidity * BigInt(maxPayoutBps)) / import_gamba_core_v26.BPS_PER_WHOLE;
  return {
    token,
    publicKey,
    minWager: account.minWager.toNumber(),
    liquidity,
    maxPayout,
    gambaFee,
    poolFee,
    jackpotBalance: Number(jackpotBalance),
    authority
  };
}

// src/hooks/index.ts
function useGambaProvider() {
  return useGambaContext().provider;
}
function useGambaProgram() {
  return useGambaProvider().gambaProgram;
}

// src/plugins.ts
var SplToken = __toESM(require("@solana/spl-token"));
var import_web35 = require("@solana/web3.js");
var createCustomFeePlugin = (_receiver, percent) => async (input, context) => {
  const receiver = new import_web35.PublicKey(_receiver);
  if (input.token.equals(SplToken.NATIVE_MINT)) {
    return [
      import_web35.SystemProgram.transfer({
        fromPubkey: input.wallet,
        toPubkey: receiver,
        lamports: input.wager * percent
      })
    ];
  }
  const fromAta = SplToken.getAssociatedTokenAddressSync(input.token, input.wallet);
  const toAta = SplToken.getAssociatedTokenAddressSync(input.token, receiver);
  const createAtaInstruction = async () => {
    try {
      await SplToken.getAccount(context.provider.anchorProvider.connection, toAta, "confirmed");
      return [];
    } catch (error) {
      if (error instanceof SplToken.TokenAccountNotFoundError || error instanceof SplToken.TokenInvalidAccountOwnerError) {
        return [
          SplToken.createAssociatedTokenAccountInstruction(
            input.wallet,
            toAta,
            receiver,
            input.token
          )
        ];
      } else {
        throw error;
      }
    }
  };
  return [
    ...await createAtaInstruction(),
    SplToken.createTransferInstruction(
      fromAta,
      toAta,
      input.wallet,
      BigInt(input.wager) / BigInt(1 / percent)
    )
  ];
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  GambaContext,
  GambaProvider,
  SendTransactionContext,
  SendTransactionProvider,
  createCustomFeePlugin,
  throwTransactionError,
  useAccount,
  useBalance,
  useGamba,
  useGambaContext,
  useGambaEventListener,
  useGambaEvents,
  useGambaPlay,
  useGambaProgram,
  useGambaProvider,
  useNextResult,
  usePool,
  useSendTransaction,
  useTransactionError,
  useTransactionStore,
  useWalletAddress
});
